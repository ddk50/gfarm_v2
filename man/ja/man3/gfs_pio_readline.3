.\" This manpage has been automatically generated by docbook2man 
.\" from a DocBook document.  This tool can be found at:
.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
.\" Please send any bug reports, improvements, comments, patches, 
.\" etc. to Steve Cheng <steve@ggi-project.org>.
.TH "GFS_PIO_READLINE" "3" "13 May 2004" "Gfarm" ""
.SH NAME
gfs_pio_readline \- 一行読み込み
.SH SYNOPSIS
.sp
\fB#include <gfarm/gfarm.h>
.sp
char *gfs_pio_readline (GFS_File \fIf\fB, char **\fIbufp\fB, size_t *\fIsizep\fB, size_t *\fIlenp\fB);
\fR
.SH "DESCRIPTION"
.PP
ファイル \fIgf\fR
から、一行読み込みます。
.PP
引数 \fIbufp\fR
は、最初は NULL で初期化されたポインタ変数のアドレスを指定します。
関数 \fBgfs_pio_readline()\fR は、入出力に用いる
バッファを動的に割り当て、そのアドレスをこのポインタ変数に記録します。
引数 \fIsizep\fR は、0 で初期化した size_t 型の変数
のアドレスを指定します。この変数は、バッファのサイズを記録するために
使われます。
あるいは、malloc(3) で割り当てたバッファを指すポインタのアドレスを
引数 \fIbufp\fR
に指定することもできます。この場合、
引数 \fIsizep\fR 
は、割り当てたバッファのサイズで初期化しておきます。
行の長さがバッファのサイズを越える場合には、バッファは自動的に
realloc(3) され、
引数 \fIbufp\fR
および
引数 \fIsizep\fR 
で指定された変数もそれに従って更新されます。
ファイルを読み終わったら、このポインタを free(3) で解放する必要が
あります。
.PP
引数 \fIlenp\fR
の指す変数には、読み込んだ長さを返します。
この長さには、行末記号の分も含みます。
.PP
関数 gfs_pio_gets(3) と同様、この関数は行末の改行記号を削除しません。
また、文字列の終わりを示す '\\0' 文字を、常に付加します。
また、
引数 \fIlenp\fR
の指す変数に返った値を使えば、文字 '\\0' を含む行を扱うこともできます。
.PP
EOF
は、入力の長さが 0 文字であることで判断します。
.PP
この関数は、gfs_pio_readdelim(f, bufp, sizep, lenp, "\\n", 1) と
等価です。
.SH "RETURN VALUES"
.TP
\fBNULL\fR
正常終了を示します。
.TP
\fBGFARM_ERR_NO_MEMORY\fR
メモリ不足のため処理を中止しました。

この場合も、\fIbufp\fR の指すポインタ変数の
指す領域を free(3) する必要がありますから注意してください。
.TP
\fBその他\fR
上記以外のエラーが生じたことを示します。
.SH "EXAMPLES"
.SS "GFS_PIO_READLINE 関数の使用例"
.PP

.nf
#include <stdio.h>
#include <stdlib.h>
#include <gfarm/gfarm.h>

int
main(int argc, char **argv)
{
	char *e;
	GFS_File gf;
	size_t bufsize = 0, len;
	char *buffer = NULL;

	e = gfarm_initialize(&argc, &argv);
	if (e != NULL) {
		fprintf(stderr, "gfarm_initialize: %s\\n", e);
		return (EXIT_FAILURE);
	}
	if (argc <= 1) {
		fprintf(stderr, "missing gfarm filename\\n");
		return (EXIT_FAILURE);
	}
	e = gfs_pio_open(argv[1], GFARM_FILE_RDONLY, &gf);
	if (e != NULL) {
		fprintf(stderr, "%s: %s\\n", argv[1], e);
		return (EXIT_FAILURE);
	}
	e = gfs_pio_set_view_global(gf, 0);
	if (e != NULL) {
		fprintf(stderr, "%s: gfs_pio_set_view_global: %s\\n",
		    argv[1], e);
		return (EXIT_FAILURE);
	}

	while ((e = gfs_pio_readline(gf, &buffer, &bufsize, &len))
	    == NULL && len > 0) {
		printf("<%6d/%6d >%s", len, bufsize, buffer);
	}
	if (buffer != NULL)
		free(buffer);
	if (e != NULL) {
		fprintf(stderr, "ERROR: %s\\n", e);
		return (EXIT_FAILURE);
	}
	e = gfs_pio_close(gf);
	if (e != NULL) {
		fprintf(stderr, "gfs_pio_close: %s\\n", e);
		return (EXIT_FAILURE);
	}
	e = gfarm_terminate();
	if (e != NULL) {
		fprintf(stderr, "gfarm_initialize: %s\\n", e);
		return (EXIT_FAILURE);
	}
	return (EXIT_SUCCESS);
}
.fi
.SH "SEE ALSO"
.PP
\fBgfs_pio_open\fR(3),
\fBgfs_pio_getline\fR(3),
\fBgfs_pio_gets\fR(3),
\fBgfs_pio_readdelim\fR(3)
